<h1>OOP의 필요성</h1>
<h2>절차적 언어의 아쉬운 점</h2>
1. 데이터의 비인간화

만약 학생을 나타내고자 한다면

String[] name 

int[] studentNumber

float[] score

int[] age

String[] major

각각의 속성에 대해 배열을 선언해주어야 한다.

이를 보완하기 위해 C언어에서는 데이터를 그룹으로 묶어 새로운 데이터형을 만드는 구조체(struct)를 사용

```C
struct Person {
  int age;
  float height;
};
```
*구조체의 한계*

여전히 구조체가 어떤 함수랑 연관있는지 찾기 어려움

=> 구조체에 함수까지 하나로 묶어보자!

(기존 c에서는 dog.h, cat.h 등 파일 단위로 분리하는 방법을 사용하기도 하였음)

프로그래밍 언어 자체에서 지원해주는 방법 => **Class**

<br>
<h2>사람이 세상을 인지하는 법</h2>

1. 누구에게 말하고 있는가?
   
   eat(pizza) 

   먹는데 누가 먹나요? 먹는 주체가 없다.

   person.eat(pizza)

   누가 어떤 동작을 하는지 나타낸다.

2. 사람이 먹는 음식의 모든 정보를 알아야 하는가?

    피자의 모든 성분, 재료, 요리방법을 알 필요없이 필요한 정보만 제공하면 된다.

<br>
사람은 세상을 물체(Object)의 집합으로 인지한다.

1. 일반적인 이야기, 모든 것을 물체로 보지는 않는다.
2. object가 객체지향프로그래밍의 객체이다.
3. 물체는 상태를 가지고 동작도 가져갈 수 있다.

<h3>상태와 동작</h3>

프로그래밍에서 변수는 상태를 저장
함수는 동작을 나타낸다.
즉 객체는 상태와 동작으로 구성된다.

<h2>OOP</h2>

1. OOP : Object Oriented Programming
2. 프로그래밍 패러당임 중 하나
3. 프로그램을 구성하는 기본 요소를 객체로 보려는 노력
4. OOP에서 프로그램이란?
   - 상호작용하는 개체들의 집합
      (절차적 프로그래밍은 실행할 명령어의 목록을 프로그램으로 취급했음)

<br>

객체지향 프로그래밍 vs 절차적 프로그래밍


<br>

<h3>절차적 프로그래밍</h3>
</br>

- 절차적 프로그래밍은 매우 객관적
- 기계어는 위에서 아래로 차례대로 실행됨
- 어셈블리 명령어는 거의 모든 경우 기계어로 1대1로 치환 가능
- 함수 호출은 특정 메모리 위치로 jmp해서 순서대로 명령어를 실행하는 것
- 명령어 실행결과에 따라 레지스터 또는 메모리에 저장된 데이터가 변경

*<h3>어떤 프로그램이라도 최종적으로는 절차적으로 실행</h3>*

<br>
<h3>객체지향 프로그래밍</h3>

- 객체지향 프로그래밍은 사람이 기준
- '사람처럼'은 주관적, 사람들의 사고방식도 변함

*<h3>OOP는 주관적이다</h3>*
- 다양한 학설 및 의견이 등장하고 사라졌다.
- 객체(Object)에 대한 정의도 다양했다.
- 지금도 어떤 자료를 보고 배우냐에 따라 OOP의 정의가 조금씩 다르다.
- 하지만 주류 OOP 언어들이 교통정리를 어느정도 끝냄

<h2>OOP가 절차적 프로그래밍을 대체하거나 다른 새로운 패러다임이 OOP를 대체하는 것이 아니다.</h2>
<br>

*<h2>문제해결에 가장 효율적인 방법을 사용하는 것이 올바르다. </h2>*
<br>

<h1>OOP의 3대 특성 / 4대 특성 / 7대 개념</h1>

- Encapsulation(캡슐화)
- Inheritance(상속)
- Polymorphism(다형성)
- Data Abstraction(데이터 추상화)
- Association(연관/결합)
- Composition(컴포지션/합성)
- Aggregation(집합/응집)

3대 특성은 캡슐화, 상속, 다형성이다.

4대 특성은 캡슐화, 상속, 다형성, 추상화인데 가끔 추상화가 빠지고 컴포지션이 들어가는 경우가 있다.

<h2>캡슐화</h2>

1. 데이터와 그 데이터에 작용하는 메서드를 하나로 묶음
2. Data hiding : 객체 안에 있는 데이터를 외부(다른클래스의 객체 등)로부터 보호

<h2>상속</h2>
이미 존재하는 객체를 기반으로 확장된 객체를 만드는 방법
확장된 객체

1. 기존의 객체에 속한 데이터와 동작을 모두 물려받는다.
2. 여기에 다른 데이터나 동작을 추가할 수 있다.

실용적인 용도: 코드 중복을 막는다.

- 여러 객체에 공통되는 데이터와 동작을 갖는 부모객체를 만든다.
- 자식 객체들은 부모를 상속받고 필요한 데이터나 메소드를 추가한다.

<h2>다형성</h2>

- OOP의 핵심
- 같은 지시를 내렸는데 다른 종류의 객체가 동작을 달리하는 것

```Java
Dog dog;
dog.shout(); //멍멍

Cat cat;
cat.shout(); // 냐옹

Bird bird;
bird.short(); //짹
```
shout이라는 같은 지시를 내렸는데
dog, cat, bird 라는 다른 객체는 서로 다른 동작을 한다.
<br>
즉 동일한 함수 시그니처를 호출했지만
객체의 종류에 따라 실제로 실행되는 함수의 구현이 다른 것이다.

다형성이 아니라면
```
if(objectType == AnimalType.Dog) {
   System.out.println("멍멍");
}
else if(objectType == AnimalType.Cat) {
   System.out.println("냐옹");
}
else if(objectType == AnimalType.bird) {
   System.out.println("짹");
}
```
과 같이 작성해야 했다.
